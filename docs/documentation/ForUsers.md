---
layout: page
title: For End-Users
description: ~
---

First and foremost, please use a decent IDE. You hearing, Armin?

I tried to shove documentation wherever possible, so that the IDE can give some hints of the type and the meaning of the variables. To do that, just hover your mouse over the thing you want some information. It may not always be helpful, but at least I tried. Also, the code is almost all type annotated, which may also help.

# Package structure
The installed package contains 4 submodules, that can be divided in two groups, plus a module that will be generated locally. However, normally, you should only need `pyimclsts.network` and the module generated by `pyimclsts.extract`.

* Message extraction/generation:
  * `pyimclsts.extract`
  It is intended to be executed to generate python classes that represent messages.
  * `pyimclsts.extractutils`
  Contains some useful functions to analyze the IMC.xml file.
* Networking:
  * `pyimclsts.core`
  Contains functions that support the network operations, such as serialization/deserialization and the CRC16 algorithm.
  * `pyimclsts.network`
  Contains functions that allow reading and writing messages in a stream fashion, namely, the `subscriber` function.

Lastly, when the `pyimclsts.extract` is run with `python3 -m pyimclsts.extract`, it creates a folder containing the IMC messages as classes, as well as other supporting data types, such as enumerations, and bitfields. It should look like this:

* `pyimc_generated`
  * `__init__.py`
  * `_base.py`
  * `bitfields.py`
  * `categories`
    * `AcousticCommunication.py`
    * `Actuation.py`
    * ...
  * `enumerations.py`
  * `messages.py`

`enumerations.py` and `bitfields.py` contain globally (in the IMC.xml) defined enumerations and bitfields (locally defined enumerations or bitfields are stored inside the corresponding message class). `messages.py` re-exports the messages defined in their corresponding category file. It re-exports, for example, the `Announce` message, found in `categories/Networking.py`.

# Publisher-Subscriber model

There are three main elements in this model: a subscriber, a publisher and a message bus. In short, a publisher application writes messages to a shared interface, also known as the message bus, and a subscriber application register with the broker the messages it wants to consume. So, in order to comply with this model, we need a message broker to receive messages from the network, execute the subscribed functions, and also distribute the messages. Additionally, the subscriber functions should be able to have state, run independently (not creating deadlocks nor race conditions), and send and receive messages.

## The `subscriber`

## The subscriber functions